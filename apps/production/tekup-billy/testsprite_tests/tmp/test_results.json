[
  {
    "projectId": "e85c2d21-c718-4d44-816c-d84908b81c72",
    "testId": "249157e8-d86b-4da4-b7fa-fdcd4b5776af",
    "userId": "e408c4d8-30d1-7092-7068-34c999d658a7",
    "title": "TC001-list_invoices_with_filters_and_pagination",
    "description": "Test the /api/v1/tools/list_invoices endpoint to verify it correctly lists invoices with various filters such as date range, state, and contactId, and supports pagination with limit and offset parameters.",
    "code": "import requests\nimport datetime\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n}\n\ndef test_list_invoices_with_filters_and_pagination():\n    \"\"\"\n    Test the /api/v1/tools/list_invoices endpoint to verify it correctly lists invoices with various filters\n    such as date range, state, and contactId, and supports pagination with limit and offset parameters.\n    \"\"\"\n    url = f\"{BASE_URL}/api/v1/tools/list_invoices\"\n\n    # Prepare a range of test payloads to test filters and pagination\n    today = datetime.date.today()\n    seven_days_ago = today - datetime.timedelta(days=7)\n    fourteen_days_ago = today - datetime.timedelta(days=14)\n\n    test_payloads = [\n        # Filter by date range only\n        {\n            \"startDate\": fourteen_days_ago.isoformat(),\n            \"endDate\": today.isoformat()\n        },\n        # Filter by state\n        {\n            \"state\": \"draft\"\n        },\n        {\n            \"state\": \"approved\"\n        },\n        {\n            \"state\": \"voided\"\n        },\n        # Pagination parameters\n        {\n            \"limit\": 5,\n            \"offset\": 0\n        },\n        {\n            \"limit\": 5,\n            \"offset\": 5\n        },\n        # Combined filters\n        {\n            \"startDate\": seven_days_ago.isoformat(),\n            \"endDate\": today.isoformat(),\n            \"state\": \"approved\",\n            \"limit\": 10,\n            \"offset\": 0\n        },\n    ]\n\n    # First, retrieve list of invoices to get a valid contactId if possible\n    # We'll try to get contactId from one of the invoices to test contactId filter\n    contact_id = None\n    try:\n        response_all = requests.post(url, json={}, headers=HEADERS, timeout=TIMEOUT)\n        response_all.raise_for_status()\n        invoices_all = response_all.json()\n        # attempt to fetch contactId from the first invoice if available\n        if invoices_all and isinstance(invoices_all, dict):\n            invoices_list = invoices_all.get(\"invoices\") or invoices_all.get(\"data\") or []\n            if isinstance(invoices_list, list) and len(invoices_list) > 0:\n                first_invoice = invoices_list[0]\n                contact_id = first_invoice.get(\"contactId\") or first_invoice.get(\"contactID\") or first_invoice.get(\"customerId\")\n    except Exception:\n        # fallback no contact id\n        contact_id = None\n\n    if contact_id:\n        test_payloads.append({\"contactId\": contact_id})\n\n    for payload in test_payloads:\n        try:\n            response = requests.post(url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n        except requests.RequestException as e:\n            assert False, f\"Request failed for payload {payload}: {e}\"\n\n        assert response.status_code == 200, f\"Expected 200 OK, got {response.status_code} for payload {payload}\"\n\n        try:\n            data = response.json()\n        except ValueError:\n            assert False, f\"Response is not valid JSON for payload {payload}\"\n\n        # Validate response structure\n        # We expect some pagination metadata and a list of invoices or similar\n        assert isinstance(data, dict), f\"Response body should be a JSON object, got {type(data)} for payload {payload}\"\n\n        # Check at least keys containing invoices and pagination\n        # The exact keys are not specified, but typical keys might be \"invoices\", \"data\", \"pagination\" etc.\n        invoices = data.get(\"invoices\") or data.get(\"data\")\n        assert invoices is not None, f\"Response missing 'invoices' or 'data' key for payload {payload}\"\n        assert isinstance(invoices, list), f\"'invoices' or 'data' key should be a list for payload {payload}\"\n\n        # Optionally check pagination metadata if available\n        pagination = data.get(\"pagination\") or data.get(\"meta\")\n        if pagination is not None:\n            assert isinstance(pagination, dict), f\"Pagination/meta should be an object if present for payload {payload}\"\n            # If limit and offset included in response metadata, verify consistency\n            limit = payload.get(\"limit\")\n            if limit is not None:\n                returned_limit = pagination.get(\"limit\") or pagination.get(\"pageSize\")\n                if returned_limit is not None:\n                    assert returned_limit <= 100, f\"Returned limit exceeds maximum 100 for payload {payload}\"\n            offset = payload.get(\"offset\")\n            if offset is not None:\n                returned_offset = pagination.get(\"offset\") or pagination.get(\"page\")\n                if returned_offset is not None:\n                    assert isinstance(returned_offset, int), f\"Returned offset/page should be an integer for payload {payload}\"\n\n        # Validate filtering matches roughly expected when possible:\n        # For state filter, verify invoices match requested state (at least non-empty and no invoices with different states)\n        if \"state\" in payload and invoices:\n            expected_state = payload[\"state\"]\n            valid_states = {\"draft\", \"approved\", \"voided\"}\n            for inv in invoices:\n                state = inv.get(\"state\")\n                assert state in valid_states, f\"Invoice state '{state}' invalid for payload {payload}\"\n                assert state == expected_state, f\"Invoice state '{state}' does not match filter '{expected_state}' for payload {payload}\"\n\n        # For contactId filter, verify invoices belong to the contactId\n        if \"contactId\" in payload and invoices:\n            expected_cid = payload[\"contactId\"]\n            for inv in invoices:\n                inv_cid = inv.get(\"contactId\") or inv.get(\"customerId\")\n                assert inv_cid == expected_cid, f\"Invoice contactId '{inv_cid}' does not match filter '{expected_cid}' for payload {payload}\"\n\ndef run():\n    test_list_invoices_with_filters_and_pagination()\n\nrun()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 136, in <module>\n  File \"<string>\", line 134, in run\n  File \"<string>\", line 83, in test_list_invoices_with_filters_and_pagination\nAssertionError: Expected 200 OK, got 500 for payload {'startDate': '2025-10-17', 'endDate': '2025-10-31'}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-31T14:40:57.528Z",
    "modified": "2025-10-31T14:41:31.878Z"
  },
  {
    "projectId": "e85c2d21-c718-4d44-816c-d84908b81c72",
    "testId": "607e828c-da6e-4a02-8f8e-9c3d2414dba5",
    "userId": "e408c4d8-30d1-7092-7068-34c999d658a7",
    "title": "TC002-create_invoice_with_multiple_line_items_and_payment_terms",
    "description": "Test the /api/v1/tools/create_invoice endpoint to ensure it creates a new invoice with required fields including contactId, entryDate, and multiple line items, and supports custom payment terms.",
    "code": "import requests\nimport datetime\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef create_customer():\n    url = f\"{BASE_URL}/api/v1/tools/create_customer\"\n    customer_name = f\"Test Customer {uuid.uuid4()}\"\n    payload = {\n        \"name\": customer_name,\n        \"email\": \"test.customer@example.com\",\n        \"phone\": \"1234567890\",\n        \"address\": {\n            \"street\": \"123 Test St\",\n            \"zipcode\": \"1000\",\n            \"city\": \"Testville\",\n            \"country\": \"DK\"\n        }\n    }\n    response = requests.post(url, json=payload, timeout=TIMEOUT)\n    response.raise_for_status()\n    data = response.json()\n    contact_id = data.get(\"contactId\") or data.get(\"id\")\n    assert contact_id is not None, \"Failed to create customer or missing contactId\"\n    return contact_id\n\ndef delete_invoice(invoice_id):\n    url = f\"{BASE_URL}/api/v1/tools/cancel_invoice\"\n    payload = {\"invoiceId\": invoice_id, \"reason\": \"Test cleanup\"}\n    try:\n        response = requests.post(url, json=payload, timeout=TIMEOUT)\n        response.raise_for_status()\n    except Exception:\n        pass  # Ignore errors on cleanup\n\ndef create_invoice_with_multiple_line_items_and_payment_terms():\n    contact_id = None\n    invoice_id = None\n    try:\n        # Create a customer to use in invoice\n        contact_id = create_customer()\n\n        url = f\"{BASE_URL}/api/v1/tools/create_invoice\"\n        entry_date = datetime.date.today().isoformat()\n        payload = {\n            \"contactId\": contact_id,\n            \"entryDate\": entry_date,\n            \"paymentTermsDays\": 45,\n            \"lines\": [\n                {\n                    \"description\": \"Product A\",\n                    \"quantity\": 2,\n                    \"unitPrice\": 100.0\n                },\n                {\n                    \"description\": \"Product B\",\n                    \"quantity\": 1,\n                    \"unitPrice\": 250.5\n                }\n            ]\n        }\n\n        response = requests.post(url, json=payload, timeout=TIMEOUT)\n        response.raise_for_status()\n        data = response.json()\n\n        # Validate response contains invoice ID and expected fields\n        invoice_id = data.get(\"invoiceId\") or data.get(\"id\")\n        assert invoice_id is not None, \"Response missing invoice ID\"\n        assert data.get(\"contactId\") == contact_id, \"ContactId in response does not match request\"\n        assert data.get(\"entryDate\") == entry_date, \"EntryDate in response does not match request\"\n        assert data.get(\"paymentTermsDays\") == 45, \"Payment terms not correctly set\"\n        lines = data.get(\"lines\")\n        assert isinstance(lines, list) and len(lines) == 2, \"Lines missing or incorrect count in response\"\n        for i, line in enumerate(payload[\"lines\"]):\n            resp_line = lines[i]\n            assert resp_line.get(\"description\") == line[\"description\"], f\"Line {i} description mismatch\"\n            assert resp_line.get(\"quantity\") == line[\"quantity\"], f\"Line {i} quantity mismatch\"\n            assert abs(resp_line.get(\"unitPrice\") - line[\"unitPrice\"]) < 0.01, f\"Line {i} unitPrice mismatch\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n    finally:\n        if invoice_id:\n            delete_invoice(invoice_id)\n\ncreate_invoice_with_multiple_line_items_and_payment_terms()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 43, in create_invoice_with_multiple_line_items_and_payment_terms\n  File \"<string>\", line 23, in create_customer\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 500 Server Error: Internal Server Error for url: http://localhost:3000/api/v1/tools/create_customer\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 89, in <module>\n  File \"<string>\", line 84, in create_invoice_with_multiple_line_items_and_payment_terms\nAssertionError: Request failed: 500 Server Error: Internal Server Error for url: http://localhost:3000/api/v1/tools/create_customer\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-31T14:40:57.536Z",
    "modified": "2025-10-31T14:41:33.210Z"
  },
  {
    "projectId": "e85c2d21-c718-4d44-816c-d84908b81c72",
    "testId": "233e7e4d-c572-4889-a873-3b1735ff95fd",
    "userId": "e408c4d8-30d1-7092-7068-34c999d658a7",
    "title": "TC003-get_invoice_details_by_id",
    "description": "Test the /api/v1/tools/get_invoice endpoint to verify it returns detailed information for a specific invoice when provided with a valid invoiceId.",
    "code": "import requests\nimport datetime\n\nBASE_URL = \"http://localhost:3000\"\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\n\ndef test_get_invoice_details_by_id():\n    # Step 1: Create customer to get valid contactId\n    customer_payload = {\n        \"name\": \"Test Customer for Invoice\",\n        \"email\": \"testcustomer@example.com\",\n        \"phone\": \"1234567890\",\n        \"address\": {\n            \"street\": \"123 Test St\",\n            \"zipcode\": \"12345\",\n            \"city\": \"Testville\",\n            \"country\": \"DK\"\n        }\n    }\n    customer_id = None\n    invoice_id = None\n\n    try:\n        resp_customer = requests.post(\n            f\"{BASE_URL}/api/v1/tools/create_customer\",\n            headers=HEADERS,\n            json=customer_payload,\n            timeout=TIMEOUT\n        )\n        resp_customer.raise_for_status()\n        customer_data = resp_customer.json()\n        # Expecting contactId in response\n        customer_id = customer_data.get(\"contactId\") or customer_data.get(\"id\") or customer_data.get(\"contactID\")\n        assert customer_id, \"No contactId returned from create_customer\"\n\n        # Step 2: Create an invoice for that customer\n        today_str = datetime.date.today().isoformat()\n        invoice_payload = {\n            \"contactId\": customer_id,\n            \"entryDate\": today_str,\n            \"paymentTermsDays\": 30,\n            \"lines\": [\n                {\n                    \"description\": \"Test line item\",\n                    \"quantity\": 1,\n                    \"unitPrice\": 100.0\n                }\n            ]\n        }\n        resp_invoice = requests.post(\n            f\"{BASE_URL}/api/v1/tools/create_invoice\",\n            headers=HEADERS,\n            json=invoice_payload,\n            timeout=TIMEOUT\n        )\n        resp_invoice.raise_for_status()\n        invoice_data = resp_invoice.json()\n        # Extract invoiceId from creation response\n        invoice_id = (\n            invoice_data.get(\"invoiceId\")\n            or invoice_data.get(\"id\")\n            or invoice_data.get(\"invoiceID\")\n            or (invoice_data.get(\"data\") and invoice_data[\"data\"].get(\"invoiceId\"))\n        )\n        assert invoice_id, \"No invoiceId returned from create_invoice\"\n\n        # Step 3: Retrieve invoice details by invoiceId\n        get_invoice_payload = {\"invoiceId\": invoice_id}\n        resp_get_invoice = requests.post(\n            f\"{BASE_URL}/api/v1/tools/get_invoice\",\n            headers=HEADERS,\n            json=get_invoice_payload,\n            timeout=TIMEOUT\n        )\n        resp_get_invoice.raise_for_status()\n        invoice_details = resp_get_invoice.json()\n\n        # Validate response contains expected keys and data\n        assert isinstance(invoice_details, dict), \"Invoice details response is not a dictionary\"\n        # Check invoiceId in response matches the requested one\n        resp_invoice_id = (\n            invoice_details.get(\"invoiceId\")\n            or invoice_details.get(\"id\")\n            or invoice_details.get(\"invoiceID\")\n        )\n        assert resp_invoice_id == invoice_id, \"Returned invoiceId does not match requested invoiceId\"\n        # Basic checks for keys expected in an invoice detail\n        required_keys = [\"contactId\", \"entryDate\", \"lines\"]\n        for key in required_keys:\n            assert key in invoice_details, f\"Key '{key}' missing in invoice details\"\n        # lines must be a non-empty list\n        assert isinstance(invoice_details[\"lines\"], list) and len(invoice_details[\"lines\"]) > 0, \"Invoice lines missing or empty\"\n\n    finally:\n        # Cleanup: Delete the created invoice if possible - no delete invoice endpoint described\n        # Cleanup: Delete created customer to keep system clean if possible\n        # Since DELETE endpoints are not described, best effort to cancel invoice and delete customer\n\n        if invoice_id:\n            try:\n                # Try to cancel the invoice to clean up\n                cancel_payload = {\"invoiceId\": invoice_id, \"reason\": \"Clean up after test\"}\n                cancel_resp = requests.post(\n                    f\"{BASE_URL}/api/v1/tools/cancel_invoice\",\n                    headers=HEADERS,\n                    json=cancel_payload,\n                    timeout=TIMEOUT\n                )\n                cancel_resp.raise_for_status()\n            except Exception:\n                pass\n\n        if customer_id:\n            try:\n                # No delete customer endpoint described; skipping deletion\n                pass\n            except Exception:\n                pass\n\n\ntest_get_invoice_details_by_id()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 123, in <module>\n  File \"<string>\", line 32, in test_get_invoice_details_by_id\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 500 Server Error: Internal Server Error for url: http://localhost:3000/api/v1/tools/create_customer\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-31T14:40:57.541Z",
    "modified": "2025-10-31T14:41:51.253Z"
  },
  {
    "projectId": "e85c2d21-c718-4d44-816c-d84908b81c72",
    "testId": "30a06998-d25d-477e-9ea0-4b12cdd5f942",
    "userId": "e408c4d8-30d1-7092-7068-34c999d658a7",
    "title": "TC004-send_approved_invoice_via_email",
    "description": "Test the /api/v1/tools/send_invoice endpoint to ensure it sends an approved invoice to the customer via email and handles cases where the invoice is not approved.",
    "code": "import requests\nfrom datetime import date, timedelta\nimport random\nimport string\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\ndef random_string(length=8):\n    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n\ndef create_customer():\n    url = f\"{BASE_URL}/api/v1/tools/create_customer\"\n    payload = {\n        \"name\": f\"Test Customer {random_string()}\",\n        \"email\": f\"test{random_string()}@example.com\",\n        \"phone\": \"+4512345678\",\n        \"address\": {\n            \"street\": \"Test Street 1\",\n            \"zipcode\": \"1000\",\n            \"city\": \"Copenhagen\",\n            \"country\": \"DK\"\n        }\n    }\n    resp = requests.post(url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json().get(\"contactId\") or resp.json().get(\"id\") or resp.json().get(\"contactID\")\n\ndef create_product():\n    url = f\"{BASE_URL}/api/v1/tools/create_product\"\n    payload = {\n        \"name\": f\"Test Product {random_string()}\",\n        \"description\": \"Test product description\",\n        \"prices\": [\n            {\n                \"currencyId\": \"DKK\",\n                \"unitPrice\": 100.0\n            }\n        ]\n    }\n    resp = requests.post(url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json().get(\"productId\") or resp.json().get(\"id\") or resp.json().get(\"productID\")\n\ndef create_invoice(contact_id, product_id):\n    url = f\"{BASE_URL}/api/v1/tools/create_invoice\"\n    today_str = date.today().isoformat()\n    payload = {\n        \"contactId\": contact_id,\n        \"entryDate\": today_str,\n        \"lines\": [\n            {\n                \"description\": \"Test invoice line\",\n                \"quantity\": 1,\n                \"unitPrice\": 100.0,\n                \"productId\": product_id\n            }\n        ],\n        \"paymentTermsDays\": 30\n    }\n    resp = requests.post(url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    json_resp = resp.json()\n    invoice_id = json_resp.get(\"invoiceId\") or json_resp.get(\"id\") or json_resp.get(\"invoiceID\")\n    assert invoice_id, \"Invoice ID not returned on creation\"\n    return invoice_id\n\ndef approve_invoice(invoice_id):\n    url = f\"{BASE_URL}/api/v1/tools/approve_invoice\"\n    payload = {\"invoiceId\": invoice_id}\n    resp = requests.post(url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    # Response can be success confirmation, validate status code\n    return resp\n\ndef get_invoice(invoice_id):\n    url = f\"{BASE_URL}/api/v1/tools/get_invoice\"\n    payload = {\"invoiceId\": invoice_id}\n    resp = requests.post(url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef send_invoice(invoice_id):\n    url = f\"{BASE_URL}/api/v1/tools/send_invoice\"\n    payload = {\"invoiceId\": invoice_id}\n    resp = requests.post(url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n    return resp\n\ndef cancel_invoice(invoice_id):\n    url = f\"{BASE_URL}/api/v1/tools/cancel_invoice\"\n    payload = {\"invoiceId\": invoice_id}\n    resp = requests.post(url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n\ndef test_send_approved_invoice_via_email():\n    contact_id = None\n    product_id = None\n    invoice_id = None\n    try:\n        # Create customer\n        contact_id = create_customer()\n        assert contact_id, \"Failed to create customer\"\n\n        # Create product\n        product_id = create_product()\n        assert product_id, \"Failed to create product\"\n\n        # Create invoice (draft by default)\n        invoice_id = create_invoice(contact_id, product_id)\n        assert invoice_id, \"Failed to create invoice\"\n\n        # Attempt to send invoice without approval - expect error\n        response = send_invoice(invoice_id)\n        assert response.status_code != 200, \"Sending unapproved invoice should not succeed\"\n        json_resp = response.json()\n        # Expect error message indicating invoice not approved\n        assert (\"not approved\" in str(json_resp).lower()) or (response.status_code >= 400), \\\n            \"Expected error about unapproved invoice\"\n\n        # Approve the invoice\n        approve_invoice(invoice_id)\n\n        # Confirm invoice state is approved\n        invoice_details = get_invoice(invoice_id)\n        state = invoice_details.get(\"state\") or invoice_details.get(\"invoiceState\") or invoice_details.get(\"status\")\n        assert state == \"approved\", f\"Invoice state expected to be 'approved', got '{state}'\"\n\n        # Now send the approved invoice\n        response = send_invoice(invoice_id)\n        assert response.status_code == 200, f\"Failed to send approved invoice, status code {response.status_code}\"\n        send_resp_json = response.json()\n        # Assume success response contains a message or status\n        assert (\"success\" in str(send_resp_json).lower()) or (\"sent\" in str(send_resp_json).lower()), \\\n            \"Expected success confirmation for sending invoice\"\n\n    finally:\n        # Cleanup: cancel or delete invoice if possible\n        if invoice_id:\n            try:\n                cancel_invoice(invoice_id)\n            except Exception:\n                pass\n        # Note: Deleting customer or product cleanup not defined in PRD\n\ntest_send_approved_invoice_via_email()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 146, in <module>\n  File \"<string>\", line 102, in test_send_approved_invoice_via_email\n  File \"<string>\", line 27, in create_customer\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 500 Server Error: Internal Server Error for url: http://localhost:3000/api/v1/tools/create_customer\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-31T14:40:57.547Z",
    "modified": "2025-10-31T14:41:31.880Z"
  },
  {
    "projectId": "e85c2d21-c718-4d44-816c-d84908b81c72",
    "testId": "5c967025-28e3-46fb-9f6c-8b5f0ddf4213",
    "userId": "e408c4d8-30d1-7092-7068-34c999d658a7",
    "title": "TC005-update_existing_invoice_fields",
    "description": "Test the /api/v1/tools/update_invoice endpoint to verify it updates an existing invoice's details including line items, customer information, entry date, and payment terms.",
    "code": "import requests\nimport datetime\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\ndef test_update_existing_invoice_fields():\n    # First, create a customer to be used for the invoice\n    customer_payload = {\n        \"name\": \"Test Customer for Update Invoice\",\n        \"email\": \"update_invoice@example.com\",\n        \"phone\": \"+4512345678\",\n        \"address\": {\n            \"street\": \"Update St 12\",\n            \"zipcode\": \"1000\",\n            \"city\": \"Copenhagen\",\n            \"country\": \"DK\"\n        }\n    }\n    customer_id = None\n    invoice_id = None\n    try:\n        # Create customer\n        resp = requests.post(f\"{BASE_URL}/api/v1/tools/create_customer\", json=customer_payload, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        customer_data = resp.json()\n        assert isinstance(customer_data, dict), \"Customer creation response is not a dict\"\n        assert \"contactId\" in customer_data, \"Customer creation response missing contactId\"\n        customer_id = customer_data[\"contactId\"]\n\n        # Create initial invoice with multiple lines and entryDate + payment terms\n        today = datetime.date.today()\n        invoice_payload = {\n            \"contactId\": customer_id,\n            \"entryDate\": today.isoformat(),\n            \"paymentTermsDays\": 30,\n            \"lines\": [\n                {\n                    \"description\": \"Initial product line 1\",\n                    \"quantity\": 2,\n                    \"unitPrice\": 100.0\n                },\n                {\n                    \"description\": \"Initial product line 2\",\n                    \"quantity\": 1,\n                    \"unitPrice\": 200.0\n                }\n            ]\n        }\n        resp = requests.post(f\"{BASE_URL}/api/v1/tools/create_invoice\", json=invoice_payload, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        invoice_data = resp.json()\n        assert isinstance(invoice_data, dict), \"Invoice creation response is not a dict\"\n        assert \"invoiceId\" in invoice_data, \"Invoice creation response missing invoiceId\"\n        invoice_id = invoice_data[\"invoiceId\"]\n\n        # Prepare update payload to change line items, customer info, entryDate, payment terms\n        new_entry_date = (today + datetime.timedelta(days=1)).isoformat()\n        update_payload = {\n            \"invoiceId\": invoice_id,\n            \"contactId\": customer_id,\n            \"entryDate\": new_entry_date,\n            \"paymentTermsDays\": 45,\n            \"lines\": [\n                {\n                    \"description\": \"Updated product line A\",\n                    \"quantity\": 3,\n                    \"unitPrice\": 150.0\n                },\n                {\n                    \"description\": \"Updated product line B\",\n                    \"quantity\": 2,\n                    \"unitPrice\": 250.0\n                }\n            ]\n        }\n\n        resp = requests.post(f\"{BASE_URL}/api/v1/tools/update_invoice\", json=update_payload, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        update_response = resp.json()\n        assert isinstance(update_response, dict), \"Update invoice response is not a dict\"\n        # No specific success field in PRD, assuming if no error and HTTP 200, update succeeded.\n\n        # Retrieve invoice details to verify the update\n        get_invoice_payload = {\"invoiceId\": invoice_id}\n        resp = requests.post(f\"{BASE_URL}/api/v1/tools/get_invoice\", json=get_invoice_payload, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        updated_invoice = resp.json()\n        assert isinstance(updated_invoice, dict), \"Get invoice response is not a dict\"\n        assert updated_invoice.get(\"invoiceId\") == invoice_id, \"Returned invoiceId does not match updated invoiceId\"\n        assert updated_invoice.get(\"contactId\") == customer_id, \"ContactId not updated correctly\"\n        assert updated_invoice.get(\"entryDate\") == new_entry_date, \"EntryDate not updated correctly\"\n        assert updated_invoice.get(\"paymentTermsDays\") == 45 or updated_invoice.get(\"paymentTermsDays\") == None or updated_invoice.get(\"paymentTermsDays\") == 0, \"PaymentTermsDays not updated correctly\"\n\n        # Check that lines have been updated correctly\n        lines = updated_invoice.get(\"lines\")\n        assert isinstance(lines, list) and len(lines) == 2, \"Invoice lines not updated correctly\"\n        descriptions = {line.get(\"description\") for line in lines}\n        assert \"Updated product line A\" in descriptions and \"Updated product line B\" in descriptions, \"Invoice line descriptions not updated\"\n\n    finally:\n        if invoice_id is not None:\n            try:\n                requests.post(f\"{BASE_URL}/api/v1/tools/cancel_invoice\", json={\"invoiceId\": invoice_id, \"reason\": \"Test cleanup\"}, headers=HEADERS, timeout=TIMEOUT)\n            except Exception:\n                pass\n        if customer_id is not None:\n            try:\n                # No delete customer endpoint defined in PRD, so no delete call for customer\n                pass\n            except Exception:\n                pass\n\ntest_update_existing_invoice_fields()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 115, in <module>\n  File \"<string>\", line 26, in test_update_existing_invoice_fields\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 500 Server Error: Internal Server Error for url: http://localhost:3000/api/v1/tools/create_customer\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-31T14:40:57.552Z",
    "modified": "2025-10-31T14:41:31.179Z"
  },
  {
    "projectId": "e85c2d21-c718-4d44-816c-d84908b81c72",
    "testId": "d010f64d-a5c5-4043-aea1-de8ae0744243",
    "userId": "e408c4d8-30d1-7092-7068-34c999d658a7",
    "title": "TC006-approve_draft_invoice_state_transition",
    "description": "Test the /api/v1/tools/approve_invoice endpoint to ensure it changes the invoice state from draft to approved correctly.",
    "code": "import requests\nimport datetime\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\nHEADERS = {\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_approve_draft_invoice_state_transition():\n    # Helper function to create a customer\n    def create_customer():\n        payload = {\n            \"name\": f\"Test Customer {uuid.uuid4()}\",\n            \"email\": \"testcustomer@example.com\",\n            \"phone\": \"1234567890\",\n            \"address\": {\n                \"street\": \"123 Test St\",\n                \"zipcode\": \"1000\",\n                \"city\": \"Testville\",\n                \"country\": \"DK\"\n            }\n        }\n        resp = requests.post(f\"{BASE_URL}/api/v1/tools/create_customer\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        data = resp.json()\n        contact_id = data.get(\"contactId\") or data.get(\"id\")\n        assert contact_id is not None, \"Failed to get contactId from create_customer response\"\n        return contact_id\n\n    # Helper function to delete a customer (if such endpoint existed; skipping here per instructions as no delete customer)\n    # Not specified in PRD, so we won't delete customer.\n\n    # Helper function to create an invoice\n    def create_invoice(contact_id):\n        today = datetime.date.today().isoformat()\n        payload = {\n            \"contactId\": contact_id,\n            \"entryDate\": today,\n            \"paymentTermsDays\": 30,\n            \"lines\": [\n                {\n                    \"description\": \"Test product line\",\n                    \"quantity\": 1,\n                    \"unitPrice\": 100.0\n                }\n            ]\n        }\n        resp = requests.post(f\"{BASE_URL}/api/v1/tools/create_invoice\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        data = resp.json()\n        invoice_id = data.get(\"invoiceId\") or data.get(\"id\")\n        assert invoice_id is not None, \"Failed to get invoiceId from create_invoice response\"\n        return invoice_id\n\n    # Helper function to get invoice details\n    def get_invoice(invoice_id):\n        payload = {\"invoiceId\": invoice_id}\n        resp = requests.post(f\"{BASE_URL}/api/v1/tools/get_invoice\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()\n\n    # Helper function to approve invoice\n    def approve_invoice(invoice_id):\n        payload = {\"invoiceId\": invoice_id}\n        resp = requests.post(f\"{BASE_URL}/api/v1/tools/approve_invoice\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()\n\n    # Helper function to cancel invoice (cleanup)\n    def cancel_invoice(invoice_id):\n        payload = {\"invoiceId\": invoice_id, \"reason\": \"Test cleanup\"}\n        resp = requests.post(f\"{BASE_URL}/api/v1/tools/cancel_invoice\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n        if resp.status_code not in (200, 204):\n            # We tolerate failure on cleanup\n            pass\n\n    invoice_id = None\n    contact_id = None\n    try:\n        # Create customer\n        contact_id = create_customer()\n\n        # Create invoice in draft state\n        invoice_id = create_invoice(contact_id)\n\n        # Verify initial state is draft\n        invoice_before = get_invoice(invoice_id)\n        state_before = invoice_before.get(\"state\") or invoice_before.get(\"status\")\n        assert state_before == \"draft\", f\"Expected invoice state 'draft' but got '{state_before}' before approval\"\n\n        # Approve the invoice\n        approve_resp = approve_invoice(invoice_id)\n        # Possible that approve_resp contains some data, no specification given, so just check HTTP Success (done above)\n\n        # Verify invoice state changed to approved\n        invoice_after = get_invoice(invoice_id)\n        state_after = invoice_after.get(\"state\") or invoice_after.get(\"status\")\n        assert state_after == \"approved\", f\"Expected invoice state 'approved' but got '{state_after}' after approval\"\n\n    finally:\n        # Cleanup: cancel the invoice if created\n        if invoice_id:\n            cancel_invoice(invoice_id)\n\ntest_approve_draft_invoice_state_transition()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 107, in <module>\n  File \"<string>\", line 83, in test_approve_draft_invoice_state_transition\n  File \"<string>\", line 26, in create_customer\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 500 Server Error: Internal Server Error for url: http://localhost:3000/api/v1/tools/create_customer\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-31T14:40:57.557Z",
    "modified": "2025-10-31T14:41:50.337Z"
  },
  {
    "projectId": "e85c2d21-c718-4d44-816c-d84908b81c72",
    "testId": "f91c8e06-e095-4cc3-bdda-1cc4c03b974a",
    "userId": "e408c4d8-30d1-7092-7068-34c999d658a7",
    "title": "TC007-cancel_invoice_with_optional_reason",
    "description": "Test the /api/v1/tools/cancel_invoice endpoint to verify it cancels an invoice and accepts an optional cancellation reason.",
    "code": "import requests\nimport datetime\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\ndef test_cancel_invoice_with_optional_reason():\n    # Step 1: Create a new customer needed for invoice creation\n    customer_payload = {\n        \"name\": \"Test Customer for Cancel Invoice\",\n        \"email\": \"cancel_invoice_test@example.com\",\n        \"phone\": \"+4512345678\",\n        \"address\": {\n            \"street\": \"Test Street 1\",\n            \"zipcode\": \"1000\",\n            \"city\": \"Copenhagen\",\n            \"country\": \"DK\"\n        }\n    }\n    customer_id = None\n    invoice_id = None\n    try:\n        r_cust = requests.post(\n            f\"{BASE_URL}/api/v1/tools/create_customer\",\n            json=customer_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        r_cust.raise_for_status()\n        customer_resp = r_cust.json()\n        assert \"contactId\" in customer_resp, \"contactId not in create_customer response\"\n        customer_id = customer_resp[\"contactId\"]\n\n        # Step 2: Create an invoice for this customer\n        today_str = datetime.date.today().isoformat()\n        invoice_payload = {\n            \"contactId\": customer_id,\n            \"entryDate\": today_str,\n            \"lines\": [\n                {\n                    \"description\": \"Test product line for cancel invoice\",\n                    \"quantity\": 1,\n                    \"unitPrice\": 200.0\n                }\n            ]\n        }\n        r_inv = requests.post(\n            f\"{BASE_URL}/api/v1/tools/create_invoice\",\n            json=invoice_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        r_inv.raise_for_status()\n        invoice_resp = r_inv.json()\n        assert \"invoiceId\" in invoice_resp, \"invoiceId not in create_invoice response\"\n        invoice_id = invoice_resp[\"invoiceId\"]\n\n        # Step 3: Cancel the invoice without reason (optional field)\n        cancel_payload_no_reason = {\"invoiceId\": invoice_id}\n        r_cancel_no_reason = requests.post(\n            f\"{BASE_URL}/api/v1/tools/cancel_invoice\",\n            json=cancel_payload_no_reason,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        r_cancel_no_reason.raise_for_status()\n        cancel_resp_no_reason = r_cancel_no_reason.json()\n        assert cancel_resp_no_reason.get(\"success\", True) or r_cancel_no_reason.status_code == 200\n\n        # (Recreate invoice because canceled invoice can't be canceled again)\n        r_inv2 = requests.post(\n            f\"{BASE_URL}/api/v1/tools/create_invoice\",\n            json=invoice_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        r_inv2.raise_for_status()\n        invoice_resp2 = r_inv2.json()\n        assert \"invoiceId\" in invoice_resp2, \"invoiceId not in create_invoice response (second invoice)\"\n        invoice_id_2 = invoice_resp2[\"invoiceId\"]\n\n        # Step 4: Cancel the invoice with a reason\n        cancel_payload_with_reason = {\n            \"invoiceId\": invoice_id_2,\n            \"reason\": \"Customer requested cancellation\"\n        }\n        r_cancel_reason = requests.post(\n            f\"{BASE_URL}/api/v1/tools/cancel_invoice\",\n            json=cancel_payload_with_reason,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        r_cancel_reason.raise_for_status()\n        cancel_resp_reason = r_cancel_reason.json()\n        assert cancel_resp_reason.get(\"success\", True) or r_cancel_reason.status_code == 200\n\n    finally:\n        # Clean up invoices if still present - No explicit delete invoice endpoint specified in PRD.\n        # Clean up customer\n        if customer_id:\n            # No delete customer endpoint described so skipping deletion.\n            pass\n\ntest_cancel_invoice_with_optional_reason()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 105, in <module>\n  File \"<string>\", line 30, in test_cancel_invoice_with_optional_reason\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 500 Server Error: Internal Server Error for url: http://localhost:3000/api/v1/tools/create_customer\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-31T14:40:57.563Z",
    "modified": "2025-10-31T14:41:49.788Z"
  },
  {
    "projectId": "e85c2d21-c718-4d44-816c-d84908b81c72",
    "testId": "0ea7d039-237d-4a96-87db-9275bade674d",
    "userId": "e408c4d8-30d1-7092-7068-34c999d658a7",
    "title": "TC008-mark_invoice_as_paid_with_payment_details",
    "description": "Test the /api/v1/tools/mark_invoice_paid endpoint to ensure it marks an invoice as paid with the provided payment date and amount.",
    "code": "import requests\nimport datetime\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n}\n\ndef test_mark_invoice_as_paid_with_payment_details():\n    # Create a new customer to use for invoice creation\n    customer_payload = {\n        \"name\": \"Test Customer for Mark Paid\",\n        \"email\": \"markpaid@test.com\"\n    }\n    customer_id = None\n    invoice_id = None\n\n    try:\n        # Create customer\n        resp = requests.post(\n            f\"{BASE_URL}/api/v1/tools/create_customer\",\n            json=customer_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        resp.raise_for_status()\n        customer_data = resp.json()\n        customer_id = customer_data.get(\"contactId\") or customer_data.get(\"id\")\n        assert customer_id, \"Customer ID not returned on creation\"\n\n        # Create invoice for this customer\n        today = datetime.date.today().isoformat()\n        invoice_payload = {\n            \"contactId\": customer_id,\n            \"entryDate\": today,\n            \"lines\": [\n                {\n                    \"description\": \"Test product line\",\n                    \"quantity\": 1,\n                    \"unitPrice\": 100\n                }\n            ]\n        }\n        resp = requests.post(\n            f\"{BASE_URL}/api/v1/tools/create_invoice\",\n            json=invoice_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        resp.raise_for_status()\n        invoice_data = resp.json()\n        invoice_id = invoice_data.get(\"invoiceId\") or invoice_data.get(\"id\")\n        assert invoice_id, \"Invoice ID not returned on creation\"\n\n        # Approve the invoice so it can be marked as paid\n        approve_payload = {\"invoiceId\": invoice_id}\n        resp = requests.post(\n            f\"{BASE_URL}/api/v1/tools/approve_invoice\",\n            json=approve_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        resp.raise_for_status()\n        approve_resp = resp.json()\n        assert approve_resp.get(\"success\", True) is not False, \"Invoice approval failed\"\n\n        # Mark the invoice as paid with paymentDate and amount\n        payment_date = today\n        payment_amount = 100\n        mark_paid_payload = {\n            \"invoiceId\": invoice_id,\n            \"paymentDate\": payment_date,\n            \"amount\": payment_amount\n        }\n        resp = requests.post(\n            f\"{BASE_URL}/api/v1/tools/mark_invoice_paid\",\n            json=mark_paid_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        resp.raise_for_status()\n        mark_paid_resp = resp.json()\n        # Assuming a success message or similar response key is returned\n        assert mark_paid_resp.get(\"success\", True) is not False, \"Marking invoice as paid failed\"\n\n        # Optionally get the invoice and validate its state is paid\n        get_invoice_payload = {\"invoiceId\": invoice_id}\n        resp = requests.post(\n            f\"{BASE_URL}/api/v1/tools/get_invoice\",\n            json=get_invoice_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        resp.raise_for_status()\n        invoice_detail = resp.json()\n        # The invoice detail should show paid state or payment info matching\n        # Typical field could be 'state' or 'paymentStatus' or checking payment date/amount\n        payment_info = invoice_detail.get(\"payment\")\n        paid_state = invoice_detail.get(\"state\")\n        assert paid_state == \"paid\" or (payment_info and payment_info.get(\"paymentDate\") == payment_date and abs(payment_info.get(\"amount\",0)-payment_amount)<0.01), \\\n            \"Invoice is not marked as paid correctly\"\n\n    finally:\n        # Clean up invoice\n        if invoice_id:\n            try:\n                requests.post(\n                    f\"{BASE_URL}/api/v1/tools/cancel_invoice\",\n                    json={\"invoiceId\": invoice_id},\n                    headers=HEADERS,\n                    timeout=TIMEOUT\n                )\n            except Exception:\n                pass\n\n        # Clean up customer\n        if customer_id:\n            try:\n                # No explicit delete customer endpoint known,\n                # if exists replace here. Otherwise ignore cleanup.\n                pass\n            except Exception:\n                pass\n\ntest_mark_invoice_as_paid_with_payment_details()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 126, in <module>\n  File \"<string>\", line 27, in test_mark_invoice_as_paid_with_payment_details\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 500 Server Error: Internal Server Error for url: http://localhost:3000/api/v1/tools/create_customer\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-31T14:40:57.568Z",
    "modified": "2025-10-31T14:41:35.531Z"
  },
  {
    "projectId": "e85c2d21-c718-4d44-816c-d84908b81c72",
    "testId": "77532669-bba5-4322-af31-91f86c6d5b5e",
    "userId": "e408c4d8-30d1-7092-7068-34c999d658a7",
    "title": "TC009-list_customers_with_search_and_pagination",
    "description": "Test the /api/v1/tools/list_customers endpoint to verify it lists customers filtered by search term and supports pagination with limit and offset.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nLIST_CUSTOMERS_ENDPOINT = f\"{BASE_URL}/api/v1/tools/list_customers\"\nCREATE_CUSTOMER_ENDPOINT = f\"{BASE_URL}/api/v1/tools/create_customer\"\nDELETE_CUSTOMER_ENDPOINT = f\"{BASE_URL}/api/v1/tools/update_customer\"\n\nHEADERS = {\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_list_customers_with_search_and_pagination():\n    # Create a customer to ensure at least one matches the search\n    new_customer_data = {\n        \"name\": \"Test SearchName Customer\",\n        \"email\": \"searchname@example.com\",\n        \"phone\": \"1234567890\",\n        \"address\": {\n            \"street\": \"123 Search St\",\n            \"zipcode\": \"1000\",\n            \"city\": \"TestCity\",\n            \"country\": \"DK\"\n        }\n    }\n\n    created_contact_id = None\n\n    try:\n        # Create customer\n        create_resp = requests.post(\n            CREATE_CUSTOMER_ENDPOINT,\n            json=new_customer_data,\n            headers=HEADERS,\n            timeout=30\n        )\n        create_resp.raise_for_status()\n        create_json = create_resp.json()\n        assert isinstance(create_json, dict), \"Create customer response is not a JSON object\"\n        # Expecting created contactId in response, try multiple possible keys:\n        contact_id_keys = ['contactId', 'id', 'contactID', 'contact_id']\n        for key in contact_id_keys:\n            if key in create_json:\n                created_contact_id = create_json[key]\n                break\n        assert created_contact_id, f\"Created contact ID not found in response: {create_json}\"\n\n        # Prepare data to list customers filtered by search term matching the created customer\n        search_term = \"SearchName\"\n        list_payload = {\n            \"search\": search_term,\n            \"limit\": 10,\n            \"offset\": 0\n        }\n\n        list_resp = requests.post(\n            LIST_CUSTOMERS_ENDPOINT,\n            json=list_payload,\n            headers=HEADERS,\n            timeout=30\n        )\n        list_resp.raise_for_status()\n        list_json = list_resp.json()\n\n        # Validate response structure\n        assert isinstance(list_json, dict) or isinstance(list_json, list), \"List customers response should be dict or list\"\n\n        # If response is dict, expect an array or list of customers under a key like 'customers' or 'data'\n        customers_list = None\n        if isinstance(list_json, dict):\n            possible_keys = ['customers', 'data', 'results', 'items']\n            for key in possible_keys:\n                if key in list_json:\n                    customers_list = list_json[key]\n                    break\n            if customers_list is None:\n                # If no recognized key, check if any key holds a list with expected items\n                customers_list = next((v for v in list_json.values() if isinstance(v, list)), None)\n        elif isinstance(list_json, list):\n            customers_list = list_json\n\n        assert customers_list is not None, \"Could not find customers list in response\"\n        assert isinstance(customers_list, list), \"Customers list is not a list\"\n\n        # Validate pagination respects limit\n        assert len(customers_list) <= 10, f\"Returned customers exceed limit: {len(customers_list)} > 10\"\n\n        # Validate that all returned customers have search term in name or relevant fields (case insensitive)\n        matched = any(\n            ('name' in cust and isinstance(cust['name'], str) and search_term.lower() in cust['name'].lower())\n            for cust in customers_list\n        )\n        assert matched, \"No listed customer matches the search term in the returned results\"\n\n    finally:\n        if created_contact_id:\n            # Try to delete the created customer if API supports deletion by updating or other means\n            # The PRD does not specify a delete API for customers; thus we try to 'update' with empty details or skip\n            # Here, as no delete endpoint is described, we skip actual deletion\n            # Pass silently if deletion not possible\n            pass\n\n\ntest_list_customers_with_search_and_pagination()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 103, in <module>\n  File \"<string>\", line 36, in test_list_customers_with_search_and_pagination\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 500 Server Error: Internal Server Error for url: http://localhost:3000/api/v1/tools/create_customer\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-31T14:40:57.574Z",
    "modified": "2025-10-31T14:41:35.568Z"
  },
  {
    "projectId": "e85c2d21-c718-4d44-816c-d84908b81c72",
    "testId": "11ee7b6d-b4fa-4e10-b864-0375bf6a9e75",
    "userId": "e408c4d8-30d1-7092-7068-34c999d658a7",
    "title": "TC010-create_customer_with_contact_information",
    "description": "Test the /api/v1/tools/create_customer endpoint to ensure it creates a new customer with required name and optional email, phone, and address details.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nCREATE_CUSTOMER_ENDPOINT = \"/api/v1/tools/create_customer\"\nDELETE_CUSTOMER_ENDPOINT = \"/api/v1/tools/update_customer\"  # No explicit delete endpoint, so this may be a logical choice if API supports deletion via update with a flag, else skip deletion\n\n\ndef test_create_customer_with_contact_information():\n    url = BASE_URL + CREATE_CUSTOMER_ENDPOINT\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    payload = {\n        \"name\": \"Test Customer TC010\",\n        \"email\": \"tc010@example.com\",\n        \"phone\": \"+4512345678\",\n        \"address\": {\n            \"street\": \"123 Test St\",\n            \"zipcode\": \"8000\",\n            \"city\": \"Aarhus\",\n            \"country\": \"DK\"\n        }\n    }\n\n    created_contact_id = None\n\n    try:\n        # Create customer\n        resp = requests.post(url, json=payload, headers=headers, timeout=30)\n        resp.raise_for_status()\n        data = resp.json()\n\n        # Validate response contains contactId or equivalent identifier\n        assert isinstance(data, dict), \"Response is not a JSON object\"\n        # We expect an ID or similar unique identifier in response e.g. \"contactId\" or \"id\"\n        # The PRD does not specify exact response schema, so check for common keys\n        contact_id = data.get(\"contactId\") or data.get(\"id\")\n        assert contact_id, \"Response does not contain contact ID\"\n        created_contact_id = contact_id\n\n        # Validate returned data includes the provided details (at least name)\n        assert data.get(\"name\") == payload[\"name\"], \"Name in response does not match request\"\n        # Optional fields - if present in response validate\n        if \"email\" in data:\n            assert data[\"email\"] == payload[\"email\"], \"Email in response does not match request\"\n        if \"phone\" in data:\n            assert data[\"phone\"] == payload[\"phone\"], \"Phone in response does not match request\"\n        if \"address\" in data:\n            addr = data[\"address\"]\n            assert addr.get(\"street\") == payload[\"address\"][\"street\"], \"Street in response does not match request\"\n            assert addr.get(\"zipcode\") == payload[\"address\"][\"zipcode\"], \"Zipcode in response does not match request\"\n            assert addr.get(\"city\") == payload[\"address\"][\"city\"], \"City in response does not match request\"\n            assert addr.get(\"country\", \"DK\") == payload[\"address\"][\"country\"], \"Country in response does not match request\"\n\n    finally:\n        # Attempt to delete the created customer if possible\n        if created_contact_id:\n            # If delete API is not specified, attempt to delete via update with an empty name or skip\n            # Here, we try to delete by sending a request to update_customer with contactId and a delete flag if API supported.\n            # Since PRD does not specify delete method, we will skip deletion.\n            pass\n\n\ntest_create_customer_with_contact_information()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 64, in <module>\n  File \"<string>\", line 30, in test_create_customer_with_contact_information\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 500 Server Error: Internal Server Error for url: http://localhost:3000/api/v1/tools/create_customer\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-31T14:40:57.579Z",
    "modified": "2025-10-31T14:41:36.301Z"
  }
]
