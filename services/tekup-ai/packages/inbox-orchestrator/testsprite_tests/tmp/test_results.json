[
  {
    "projectId": "07ddd02e-d7fe-48da-9824-065469acec10",
    "testId": "70311de5-3f0f-4d5e-816b-2cbccb998322",
    "userId": "e408c4d8-30d1-7092-7068-34c999d658a7",
    "title": "TC001-health check api should return service status",
    "description": "Verify that the /health GET endpoint returns a 200 status with a JSON object containing { ok: true } indicating the service is healthy.",
    "code": "import requests\n\ndef test_health_check_api_should_return_service_status():\n    url = \"http://localhost:3011/health\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=30)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n    assert isinstance(data, dict), \"Response JSON is not an object\"\n    assert \"ok\" in data, \"Response JSON does not contain 'ok' key\"\n    assert data[\"ok\"] is True, \"Response 'ok' key value is not True\"\n\ntest_health_check_api_should_return_service_status()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-31T15:09:23.078Z",
    "modified": "2025-10-31T15:09:34.522Z"
  },
  {
    "projectId": "07ddd02e-d7fe-48da-9824-065469acec10",
    "testId": "066851ea-7599-43b0-944e-5ed4077b9684",
    "userId": "e408c4d8-30d1-7092-7068-34c999d658a7",
    "title": "TC002-lead parser test api should parse mock email thread correctly",
    "description": "Test the /test/parser GET endpoint to ensure it returns a 200 status with a success flag and correctly structured parsed lead data including name, type, source, contact info, bolig details, address, and status.",
    "code": "import requests\n\ndef test_lead_parser_api_should_parse_mock_email_thread_correctly():\n    base_url = \"http://localhost:3011\"\n    url = f\"{base_url}/test/parser\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    timeout = 30\n\n    try:\n        response = requests.get(url, headers=headers, timeout=timeout)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed: {e}\"\n\n    json_data = response.json()\n\n    # Validate response status code\n    assert response.status_code == 200, f\"Expected status 200 but got {response.status_code}\"\n    # Validate success flag\n    assert isinstance(json_data.get(\"success\"), bool), \"Missing or invalid 'success' flag in response\"\n    assert json_data[\"success\"] is True, \"'success' flag is not True\"\n    # Validate parsed object\n    parsed = json_data.get(\"parsed\")\n    assert isinstance(parsed, dict), \"Missing or invalid 'parsed' object in response\"\n\n    # Validate required fields in parsed\n    expected_fields = [\"name\", \"type\", \"source\", \"contact\", \"bolig\", \"address\", \"status\"]\n    for field in expected_fields:\n        assert field in parsed, f\"Missing '{field}' in parsed data\"\n\n    # Validate types of fields\n    assert isinstance(parsed[\"name\"], str), \"'name' field is not a string\"\n    assert isinstance(parsed[\"type\"], str), \"'type' field is not a string\"\n    assert isinstance(parsed[\"source\"], str), \"'source' field is not a string\"\n    assert isinstance(parsed[\"address\"], str), \"'address' field is not a string\"\n    assert isinstance(parsed[\"status\"], str), \"'status' field is not a string\"\n\n    # Validate contact object\n    contact = parsed[\"contact\"]\n    assert isinstance(contact, dict), \"'contact' is not an object\"\n    assert \"email\" in contact and isinstance(contact[\"email\"], str), \"'contact.email' missing or not string\"\n    assert \"phone\" in contact and isinstance(contact[\"phone\"], str), \"'contact.phone' missing or not string\"\n\n    # Validate bolig object\n    bolig = parsed[\"bolig\"]\n    assert isinstance(bolig, dict), \"'bolig' is not an object\"\n    assert \"sqm\" in bolig and (isinstance(bolig[\"sqm\"], int) or isinstance(bolig[\"sqm\"], float)), \"'bolig.sqm' missing or not a number\"\n    assert \"type\" in bolig and isinstance(bolig[\"type\"], str), \"'bolig.type' missing or not string\"\n\ntest_lead_parser_api_should_parse_mock_email_thread_correctly()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-31T15:09:23.084Z",
    "modified": "2025-10-31T15:09:55.646Z"
  },
  {
    "projectId": "07ddd02e-d7fe-48da-9824-065469acec10",
    "testId": "e078609f-a8e1-4329-915f-d0afa4bd1a77",
    "userId": "e408c4d8-30d1-7092-7068-34c999d658a7",
    "title": "TC003-generate reply api should produce safe reply with memory enforcement",
    "description": "Validate the /generate-reply POST endpoint with a valid threadId to ensure it returns a 200 status with a generated reply recommendation, any memory rule warnings, and a shouldSend boolean indicating if the reply is safe to send.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3011\"\nTIMEOUT = 30\n\ndef test_generate_reply_api_should_produce_safe_reply_with_memory_enforcement():\n    # Since no specific threadId provided, create a dummy thread first\n    # NOTE: The PRD does not specify an endpoint to create threads,\n    # so we simulate by generating a UUID as a dummy threadId to test input handling.\n    thread_id = str(uuid.uuid4())\n\n    url = f\"{BASE_URL}/generate-reply\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    payload = {\n        \"threadId\": thread_id,\n        \"policy\": {\n            \"searchBeforeSend\": True\n        }\n    }\n\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n        # Check that response status code is 200\n        assert response.status_code == 200, f\"Expected status 200 but got {response.status_code}\"\n        \n        resp_json = response.json()\n        \n        # Validate presence and types of keys\n        assert \"recommendation\" in resp_json and isinstance(resp_json[\"recommendation\"], str), \\\n            \"Missing or invalid 'recommendation' in response\"\n        assert \"warnings\" in resp_json and isinstance(resp_json[\"warnings\"], list), \\\n            \"Missing or invalid 'warnings' in response\"\n        assert all(isinstance(w, str) for w in resp_json[\"warnings\"]), \"All warnings should be strings\"\n        assert \"shouldSend\" in resp_json and isinstance(resp_json[\"shouldSend\"], bool), \\\n            \"Missing or invalid 'shouldSend' in response\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_generate_reply_api_should_produce_safe_reply_with_memory_enforcement()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-31T15:09:23.089Z",
    "modified": "2025-10-31T15:09:36.417Z"
  },
  {
    "projectId": "07ddd02e-d7fe-48da-9824-065469acec10",
    "testId": "83d70dd1-2b7a-45a7-a7a7-f03013b86bf5",
    "userId": "e408c4d8-30d1-7092-7068-34c999d658a7",
    "title": "TC004-approve and send api should send reply and manage labels",
    "description": "Test the /approve-and-send POST endpoint with valid threadId, body, and optional labels to add or remove, verifying that the email is sent successfully and the response contains an ok flag and data object.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3011\"\nTIMEOUT = 30\n\ndef test_approve_and_send_api_should_send_reply_and_manage_labels():\n    # First, create a mock threadId by simulating a generate-reply request or use a placeholder if not available.\n    # Since no resource ID is provided, we create a new resource by generating a reply to get a threadId.\n    try:\n        # Step 1: Generate a reply to get a valid threadId and a sample reply body\n        generate_reply_resp = requests.post(\n            f\"{BASE_URL}/generate-reply\",\n            json={\"threadId\": \"test-thread-for-approve-send\"},\n            timeout=TIMEOUT,\n        )\n        assert generate_reply_resp.status_code == 200, f\"Expected 200, got {generate_reply_resp.status_code}\"\n        gen_reply_json = generate_reply_resp.json()\n        assert \"recommendation\" in gen_reply_json, \"No recommendation found in generate-reply response\"\n        reply_body = gen_reply_json[\"recommendation\"]\n        thread_id = \"test-thread-for-approve-send\"\n\n        # Step 2: Prepare payload with body and some labels to add/remove\n        payload = {\n            \"threadId\": thread_id,\n            \"body\": reply_body,\n            \"labels\": {\n                \"add\": [\"Approved\", \"Sent\"],\n                \"remove\": [\"Pending\"]\n            }\n        }\n\n        # Step 3: Call the approve-and-send POST endpoint\n        approve_send_resp = requests.post(\n            f\"{BASE_URL}/approve-and-send\",\n            json=payload,\n            timeout=TIMEOUT,\n        )\n        # Step 4: Validate the response status and content\n        assert approve_send_resp.status_code == 200, f\"Expected 200, got {approve_send_resp.status_code}\"\n        resp_json = approve_send_resp.json()\n        assert isinstance(resp_json, dict), \"Response is not a JSON object\"\n        assert resp_json.get(\"ok\") is True, \"Response 'ok' flag is not True\"\n        assert \"data\" in resp_json and isinstance(resp_json[\"data\"], dict), \"Response 'data' object missing or invalid\"\n\n    except AssertionError as e:\n        raise\n    except Exception as ex:\n        raise RuntimeError(f\"Test failed due to exception: {ex}\")\n\ntest_approve_and_send_api_should_send_reply_and_manage_labels()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-31T15:09:23.094Z",
    "modified": "2025-10-31T15:09:41.582Z"
  },
  {
    "projectId": "07ddd02e-d7fe-48da-9824-065469acec10",
    "testId": "0e42fee9-e06c-44c1-969e-47f0128cdf84",
    "userId": "e408c4d8-30d1-7092-7068-34c999d658a7",
    "title": "TC005-chat api should process natural language queries with intent detection",
    "description": "Verify the /chat POST endpoint processes a natural language message, detects the correct intent, performs relevant actions, and returns a formatted reply with metrics including tokens used and latency.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3011/health\"\nTIMEOUT = 30\n\ndef test_chat_api_should_process_natural_language_queries_with_intent_detection():\n    url = BASE_URL.rstrip(\"/health\") + \"/chat\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    payload = {\n        \"message\": \"Hvad har vi fået af nye leads i dag?\"\n    }\n\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Validate required fields presence\n    assert \"reply\" in data, \"Response JSON missing 'reply'\"\n    assert isinstance(data[\"reply\"], str) and data[\"reply\"], \"'reply' should be a non-empty string\"\n\n    assert \"actions\" in data, \"Response JSON missing 'actions'\"\n    assert isinstance(data[\"actions\"], list), \"'actions' should be a list of performed actions\"\n    for action in data[\"actions\"]:\n        assert isinstance(action, dict), \"Each action should be an object\"\n        assert \"name\" in action and isinstance(action[\"name\"], str), \"Each action must have a 'name' string\"\n        assert \"args\" in action and isinstance(action[\"args\"], dict), \"Each action must have an 'args' object\"\n\n    assert \"metrics\" in data, \"Response JSON missing 'metrics'\"\n    metrics = data[\"metrics\"]\n    assert isinstance(metrics, dict), \"'metrics' should be an object\"\n\n    # Check intent\n    assert \"intent\" in metrics, \"'metrics' missing 'intent'\"\n    valid_intents = [\n        \"lead_processing\",\n        \"booking\",\n        \"quote_generation\",\n        \"conflict_resolution\",\n        \"follow_up\",\n        \"calendar_query\",\n        \"general\",\n        \"unknown\"\n    ]\n    assert metrics[\"intent\"] in valid_intents, f\"Intent '{metrics['intent']}' not in valid intents list\"\n\n    # Check tokens used\n    assert \"tokens\" in metrics, \"'metrics' missing 'tokens'\"\n    assert isinstance(metrics[\"tokens\"], (int, float)), \"'tokens' should be a number\"\n    assert metrics[\"tokens\"] > 0, \"'tokens' should be greater than 0\"\n\n    # Check latency format and value\n    assert \"latency\" in metrics, \"'metrics' missing 'latency'\"\n    latency = metrics[\"latency\"]\n    # latency should be a string representing milliseconds, e.g., \"123ms\" or a number string like \"123\"\n    assert isinstance(latency, str), \"'latency' should be a string\"\n    # Strip possible 'ms' suffix and convert to float\n    latency_value_str = latency.lower().replace(\"ms\", \"\").strip()\n    try:\n        latency_value = float(latency_value_str)\n    except ValueError:\n        assert False, \"'latency' string does not represent a valid number\"\n    assert 0 <= latency_value < 5000, f\"Latency {latency_value}ms is out of expected range (<5000ms)\"\n\ntest_chat_api_should_process_natural_language_queries_with_intent_detection()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-31T15:09:23.100Z",
    "modified": "2025-10-31T15:09:37.726Z"
  }
]
