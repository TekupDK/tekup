{"version":3,"sources":["C:\\Users\\empir\\Tekup-org\\apps\\flow-api\\src\\performance\\__tests__\\query-optimizer.service.spec.ts"],"sourcesContent":["import { Test, TestingModule } from '@nestjs/testing';\r\nimport { QueryOptimizerService } from '../query-optimizer.service.js';\r\nimport { PrismaService } from '../../prisma/prisma.service.js';\r\n\r\ndescribe('QueryOptimizerService', () => {\r\n  let service: QueryOptimizerService;\r\n  let prismaService: jest.Mocked<PrismaService>;\r\n\r\n  beforeEach(async () => {\r\n    const mockPrismaService = {\r\n      $queryRawUnsafe: jest.fn(),\r\n    };\r\n\r\n    const module: TestingModule = await Test.createTestingModule({\r\n      providers: [\r\n        QueryOptimizerService,\r\n        { provide: PrismaService, useValue: mockPrismaService },\r\n      ],\r\n    }).compile();\r\n\r\n    service = module.get<QueryOptimizerService>(QueryOptimizerService);\r\n    prismaService = module.get(PrismaService);\r\n  });\r\n\r\n  it('should be defined', () => {\r\n    expect(service).toBeDefined();\r\n  });\r\n\r\n  describe('analyzeQuery', () => {\r\n    it('should analyze a simple SELECT query', async () => {\r\n      const query = 'SELECT * FROM leads WHERE tenant_id = $1';\r\n      \r\n      // Mock the EXPLAIN query result\r\n      prismaService.$queryRawUnsafe.mockResolvedValue([\r\n        {\r\n          'QUERY PLAN': [\r\n            {\r\n              Plan: {\r\n                'Node Type': 'Seq Scan',\r\n                'Total Cost': 100.0,\r\n                'Plan Rows': 1000,\r\n                'Plan Width': 50,\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      ]);\r\n\r\n      const result = await service.analyzeQuery(query, ['tenant1']);\r\n\r\n      expect(result.originalQuery).toBe(query);\r\n      expect(result.queryPlan).toHaveLength(1);\r\n      expect(result.queryPlan[0].nodeType).toBe('Seq Scan');\r\n      expect(result.suggestions).toContain('Replace SELECT * with specific column names to reduce data transfer');\r\n      expect(result.indexRecommendations).toBeDefined();\r\n    });\r\n\r\n    it('should handle query analysis errors gracefully', async () => {\r\n      const query = 'SELECT * FROM invalid_table WHERE bad_syntax';\r\n      \r\n      // Mock the EXPLAIN query to fail\r\n      prismaService.$queryRawUnsafe.mockRejectedValue(new Error('Syntax error'));\r\n\r\n      const result = await service.analyzeQuery(query);\r\n\r\n      expect(result.originalQuery).toBe(query);\r\n      expect(result.queryPlan).toHaveLength(0);\r\n      // Should still provide basic optimization suggestions even when query plan fails\r\n      expect(result.suggestions.length).toBeGreaterThan(0);\r\n      expect(result.suggestions).toContain('Replace SELECT * with specific column names to reduce data transfer');\r\n    });\r\n\r\n    it('should recommend indexes for sequential scans', async () => {\r\n      const query = 'SELECT id FROM leads WHERE status = \\'new\\'';\r\n      \r\n      prismaService.$queryRawUnsafe.mockResolvedValue([\r\n        {\r\n          'QUERY PLAN': [\r\n            {\r\n              Plan: {\r\n                'Node Type': 'Seq Scan',\r\n                'Total Cost': 1000.0,\r\n                'Plan Rows': 5000,\r\n                'Plan Width': 4,\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      ]);\r\n\r\n      const result = await service.analyzeQuery(query);\r\n\r\n      expect(result.indexRecommendations).toHaveLength(1);\r\n      expect(result.indexRecommendations[0].table).toBe('leads');\r\n      expect(result.indexRecommendations[0].reason).toBe('Sequential scan detected on large table');\r\n      expect(result.indexRecommendations[0].priority).toBe('medium');\r\n    });\r\n\r\n    it('should suggest GIN indexes for JSON operations', async () => {\r\n      const query = 'SELECT id FROM leads WHERE payload->\\'email\\' = \\'test@example.com\\'';\r\n      \r\n      prismaService.$queryRawUnsafe.mockResolvedValue([]);\r\n\r\n      const result = await service.analyzeQuery(query);\r\n\r\n      expect(result.indexRecommendations.some(rec => rec.type === 'gin')).toBe(true);\r\n    });\r\n  });\r\n\r\n  describe('generateIndexSQL', () => {\r\n    it('should generate correct B-tree index SQL', () => {\r\n      const recommendation = {\r\n        table: 'leads',\r\n        columns: ['tenant_id', 'status'],\r\n        type: 'btree' as const,\r\n        reason: 'Test',\r\n        estimatedImprovement: 50,\r\n        priority: 'high' as const,\r\n      };\r\n\r\n      const sql = service.generateIndexSQL(recommendation);\r\n\r\n      expect(sql).toBe('CREATE INDEX CONCURRENTLY idx_leads_tenant_id_status ON leads (tenant_id, status);');\r\n    });\r\n\r\n    it('should generate correct GIN index SQL', () => {\r\n      const recommendation = {\r\n        table: 'leads',\r\n        columns: ['payload'],\r\n        type: 'gin' as const,\r\n        reason: 'JSON operations',\r\n        estimatedImprovement: 70,\r\n        priority: 'high' as const,\r\n      };\r\n\r\n      const sql = service.generateIndexSQL(recommendation);\r\n\r\n      expect(sql).toBe('CREATE INDEX CONCURRENTLY idx_leads_payload ON leads USING GIN (payload);');\r\n    });\r\n  });\r\n\r\n  describe('getFrequentQueries', () => {\r\n    it('should track and return frequent queries', async () => {\r\n      const query1 = 'SELECT * FROM leads WHERE tenant_id = $1';\r\n      const query2 = 'SELECT count(*) FROM leads WHERE status = $1';\r\n\r\n      // Analyze the same queries multiple times\r\n      await service.analyzeQuery(query1);\r\n      await service.analyzeQuery(query1);\r\n      await service.analyzeQuery(query2);\r\n\r\n      const frequentQueries = service.getFrequentQueries();\r\n\r\n      expect(frequentQueries).toHaveLength(2);\r\n      expect(frequentQueries[0].frequency).toBe(2); // Most frequent first\r\n    });\r\n  });\r\n});"],"names":["describe","service","prismaService","beforeEach","mockPrismaService","$queryRawUnsafe","jest","fn","module","Test","createTestingModule","providers","QueryOptimizerService","provide","PrismaService","useValue","compile","get","it","expect","toBeDefined","query","mockResolvedValue","Plan","result","analyzeQuery","originalQuery","toBe","queryPlan","toHaveLength","nodeType","suggestions","toContain","indexRecommendations","mockRejectedValue","Error","length","toBeGreaterThan","table","reason","priority","some","rec","type","recommendation","columns","estimatedImprovement","sql","generateIndexSQL","query1","query2","frequentQueries","getFrequentQueries","frequency"],"mappings":";;;;yBAAoC;uCACE;+BACR;AAE9BA,SAAS,yBAAyB;IAChC,IAAIC;IACJ,IAAIC;IAEJC,WAAW;QACT,MAAMC,oBAAoB;YACxBC,iBAAiBC,KAAKC,EAAE;QAC1B;QAEA,MAAMC,SAAwB,MAAMC,aAAI,CAACC,mBAAmB,CAAC;YAC3DC,WAAW;gBACTC,4CAAqB;gBACrB;oBAAEC,SAASC,4BAAa;oBAAEC,UAAUX;gBAAkB;aACvD;QACH,GAAGY,OAAO;QAEVf,UAAUO,OAAOS,GAAG,CAAwBL,4CAAqB;QACjEV,gBAAgBM,OAAOS,GAAG,CAACH,4BAAa;IAC1C;IAEAI,GAAG,qBAAqB;QACtBC,OAAOlB,SAASmB,WAAW;IAC7B;IAEApB,SAAS,gBAAgB;QACvBkB,GAAG,wCAAwC;YACzC,MAAMG,QAAQ;YAEd,gCAAgC;YAChCnB,cAAcG,eAAe,CAACiB,iBAAiB,CAAC;gBAC9C;oBACE,cAAc;wBACZ;4BACEC,MAAM;gCACJ,aAAa;gCACb,cAAc;gCACd,aAAa;gCACb,cAAc;4BAChB;wBACF;qBACD;gBACH;aACD;YAED,MAAMC,SAAS,MAAMvB,QAAQwB,YAAY,CAACJ,OAAO;gBAAC;aAAU;YAE5DF,OAAOK,OAAOE,aAAa,EAAEC,IAAI,CAACN;YAClCF,OAAOK,OAAOI,SAAS,EAAEC,YAAY,CAAC;YACtCV,OAAOK,OAAOI,SAAS,CAAC,EAAE,CAACE,QAAQ,EAAEH,IAAI,CAAC;YAC1CR,OAAOK,OAAOO,WAAW,EAAEC,SAAS,CAAC;YACrCb,OAAOK,OAAOS,oBAAoB,EAAEb,WAAW;QACjD;QAEAF,GAAG,kDAAkD;YACnD,MAAMG,QAAQ;YAEd,iCAAiC;YACjCnB,cAAcG,eAAe,CAAC6B,iBAAiB,CAAC,IAAIC,MAAM;YAE1D,MAAMX,SAAS,MAAMvB,QAAQwB,YAAY,CAACJ;YAE1CF,OAAOK,OAAOE,aAAa,EAAEC,IAAI,CAACN;YAClCF,OAAOK,OAAOI,SAAS,EAAEC,YAAY,CAAC;YACtC,iFAAiF;YACjFV,OAAOK,OAAOO,WAAW,CAACK,MAAM,EAAEC,eAAe,CAAC;YAClDlB,OAAOK,OAAOO,WAAW,EAAEC,SAAS,CAAC;QACvC;QAEAd,GAAG,iDAAiD;YAClD,MAAMG,QAAQ;YAEdnB,cAAcG,eAAe,CAACiB,iBAAiB,CAAC;gBAC9C;oBACE,cAAc;wBACZ;4BACEC,MAAM;gCACJ,aAAa;gCACb,cAAc;gCACd,aAAa;gCACb,cAAc;4BAChB;wBACF;qBACD;gBACH;aACD;YAED,MAAMC,SAAS,MAAMvB,QAAQwB,YAAY,CAACJ;YAE1CF,OAAOK,OAAOS,oBAAoB,EAAEJ,YAAY,CAAC;YACjDV,OAAOK,OAAOS,oBAAoB,CAAC,EAAE,CAACK,KAAK,EAAEX,IAAI,CAAC;YAClDR,OAAOK,OAAOS,oBAAoB,CAAC,EAAE,CAACM,MAAM,EAAEZ,IAAI,CAAC;YACnDR,OAAOK,OAAOS,oBAAoB,CAAC,EAAE,CAACO,QAAQ,EAAEb,IAAI,CAAC;QACvD;QAEAT,GAAG,kDAAkD;YACnD,MAAMG,QAAQ;YAEdnB,cAAcG,eAAe,CAACiB,iBAAiB,CAAC,EAAE;YAElD,MAAME,SAAS,MAAMvB,QAAQwB,YAAY,CAACJ;YAE1CF,OAAOK,OAAOS,oBAAoB,CAACQ,IAAI,CAACC,CAAAA,MAAOA,IAAIC,IAAI,KAAK,QAAQhB,IAAI,CAAC;QAC3E;IACF;IAEA3B,SAAS,oBAAoB;QAC3BkB,GAAG,4CAA4C;YAC7C,MAAM0B,iBAAiB;gBACrBN,OAAO;gBACPO,SAAS;oBAAC;oBAAa;iBAAS;gBAChCF,MAAM;gBACNJ,QAAQ;gBACRO,sBAAsB;gBACtBN,UAAU;YACZ;YAEA,MAAMO,MAAM9C,QAAQ+C,gBAAgB,CAACJ;YAErCzB,OAAO4B,KAAKpB,IAAI,CAAC;QACnB;QAEAT,GAAG,yCAAyC;YAC1C,MAAM0B,iBAAiB;gBACrBN,OAAO;gBACPO,SAAS;oBAAC;iBAAU;gBACpBF,MAAM;gBACNJ,QAAQ;gBACRO,sBAAsB;gBACtBN,UAAU;YACZ;YAEA,MAAMO,MAAM9C,QAAQ+C,gBAAgB,CAACJ;YAErCzB,OAAO4B,KAAKpB,IAAI,CAAC;QACnB;IACF;IAEA3B,SAAS,sBAAsB;QAC7BkB,GAAG,4CAA4C;YAC7C,MAAM+B,SAAS;YACf,MAAMC,SAAS;YAEf,0CAA0C;YAC1C,MAAMjD,QAAQwB,YAAY,CAACwB;YAC3B,MAAMhD,QAAQwB,YAAY,CAACwB;YAC3B,MAAMhD,QAAQwB,YAAY,CAACyB;YAE3B,MAAMC,kBAAkBlD,QAAQmD,kBAAkB;YAElDjC,OAAOgC,iBAAiBtB,YAAY,CAAC;YACrCV,OAAOgC,eAAe,CAAC,EAAE,CAACE,SAAS,EAAE1B,IAAI,CAAC,IAAI,sBAAsB;QACtE;IACF;AACF"}