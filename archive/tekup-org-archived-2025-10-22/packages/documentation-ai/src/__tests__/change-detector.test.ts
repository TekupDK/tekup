import { ChangeDetector } from '../change-detector.js';
import { AIConfig, ChangeDetectionConfig } from '../types.js';

// Mock dependencies
jest.mock('simple-git');
jest.mock('fs/promises');
jest.mock('../documentation-ai.js');

describe('ChangeDetector', () => {
  let changeDetector: ChangeDetector;
  let mockAIConfig: AIConfig;
  let mockConfig: ChangeDetectionConfig;

  beforeEach(() => {
    mockAIConfig = {
      openai: {
        apiKey: 'test-key',
        model: 'gpt-4',
        maxTokens: 4000
      },
      defaultProvider: 'openai',
      translationProvider: 'openai'
    };

    mockConfig = {
      watchPaths: ['src/', 'apps/'],
      ignorePaths: ['node_modules/', 'dist/'],
      documentationPaths: ['docs/', 'README.md'],
      autoSync: true,
      validationEnabled: true,
      rollbackEnabled: true,
      notificationChannels: []
    };

    changeDetector = new ChangeDetector('/test/repo', mockAIConfig, mockConfig);
  });

  describe('startWatching', () => {
    it('should start watching for changes', async () => {
      const mockSimpleGit = require('simple-git');
      mockSimpleGit.mockReturnValue({
        revparse: jest.fn().mockResolvedValue('/test/repo/.git')
      });

      const mockFs = require('fs/promises');
      mockFs.writeFile = jest.fn().mockResolvedValue(undefined);

      await changeDetector.startWatching();

      expect(mockFs.writeFile).toHaveBeenCalledWith(
        expect.stringContaining('post-commit'),
        expect.stringContaining('Auto-generated by TekUp Documentation AI'),
        { mode: 0o755 }
      );
    });

    it('should not start watching if already watching', async () => {
      const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();
      
      // Start watching first time
      await changeDetector.startWatching();
      
      // Try to start again
      await changeDetector.startWatching();
      
      expect(consoleSpy).toHaveBeenCalledWith('Change detector is already watching');
      consoleSpy.mockRestore();
    });
  });

  describe('getRecentChanges', () => {
    it('should get recent changes from git', async () => {
      const mockSimpleGit = require('simple-git');
      mockSimpleGit.mockReturnValue({
        log: jest.fn().mockResolvedValue({
          all: [{ hash: 'abc123' }],
          latest: { hash: 'abc123' }
        }),
        diff: jest.fn()
          .mockResolvedValueOnce('M\tsrc/test.ts')
          .mockResolvedValueOnce('diff --git a/src/test.ts b/src/test.ts\n+added line')
      });

      const changes = await changeDetector.getRecentChanges();

      expect(changes).toHaveLength(1);
      expect(changes[0].type).toBe('modified');
      expect(changes[0].file).toBe('src/test.ts');
    });

    it('should return empty array when no commits', async () => {
      const mockSimpleGit = require('simple-git');
      mockSimpleGit.mockReturnValue({
        log: jest.fn().mockResolvedValue({ all: [] })
      });

      const changes = await changeDetector.getRecentChanges();
      expect(changes).toEqual([]);
    });
  });

  describe('shouldIgnoreFile', () => {
    it('should ignore files in ignore paths', () => {
      const shouldIgnore = changeDetector['shouldIgnoreFile']('node_modules/test.js');
      expect(shouldIgnore).toBe(true);
    });

    it('should not ignore files in watch paths', () => {
      const shouldIgnore = changeDetector['shouldIgnoreFile']('src/test.ts');
      expect(shouldIgnore).toBe(false);
    });

    it('should ignore files not in watch paths', () => {
      const shouldIgnore = changeDetector['shouldIgnoreFile']('other/test.ts');
      expect(shouldIgnore).toBe(true);
    });
  });

  describe('validateDocumentation', () => {
    it('should validate documentation successfully', async () => {
      const mockFs = require('fs/promises');
      mockFs.access = jest.fn().mockResolvedValue(undefined);
      mockFs.readFile = jest.fn().mockResolvedValue('# Valid markdown\n\nContent here.');

      const validation = await changeDetector.validateDocumentation();

      expect(validation.success).toBe(true);
      expect(validation.errors).toHaveLength(0);
    });

    it('should detect missing documentation files', async () => {
      const mockFs = require('fs/promises');
      mockFs.access = jest.fn().mockRejectedValue(new Error('File not found'));

      const validation = await changeDetector.validateDocumentation();

      expect(validation.success).toBe(false);
      expect(validation.errors.length).toBeGreaterThan(0);
      expect(validation.errors[0]).toContain('Documentation file not found');
    });

    it('should detect markdown syntax errors', async () => {
      const mockFs = require('fs/promises');
      mockFs.access = jest.fn().mockResolvedValue(undefined);
      mockFs.readFile = jest.fn().mockResolvedValue('# Invalid markdown\n\n[broken link]()');

      const validation = await changeDetector.validateDocumentation();

      expect(validation.success).toBe(false);
      expect(validation.errors.some(error => error.includes('Empty links found'))).toBe(true);
    });
  });

  describe('processChanges', () => {
    it('should process changes and update documentation', async () => {
      const mockDocumentationAI = require('../documentation-ai.js').DocumentationAI;
      mockDocumentationAI.prototype.analyzeCodeChanges = jest.fn().mockResolvedValue([
        {
          type: 'api-change',
          files: ['docs/api.md'],
          suggestedChanges: ['Add new endpoint documentation'],
          priority: 'medium',
          confidence: 0.9,
          reasoning: 'New API endpoint detected'
        }
      ]);

      const mockFs = require('fs/promises');
      mockFs.readFile = jest.fn().mockResolvedValue('# Existing docs');
      mockFs.writeFile = jest.fn().mockResolvedValue(undefined);
      mockFs.access = jest.fn().mockResolvedValue(undefined);

      const mockSimpleGit = require('simple-git');
      mockSimpleGit.mockReturnValue({
        add: jest.fn().mockResolvedValue(undefined),
        commit: jest.fn().mockResolvedValue(undefined)
      });

      const changes = [
        {
          type: 'modified' as const,
          file: 'src/api.ts',
          diff: 'diff content',
          timestamp: new Date()
        }
      ];

      await changeDetector.processChanges(changes);

      expect(mockDocumentationAI.prototype.analyzeCodeChanges).toHaveBeenCalledWith('diff content');
      expect(mockFs.writeFile).toHaveBeenCalled();
    });

    it('should handle processing errors gracefully', async () => {
      const mockDocumentationAI = require('../documentation-ai.js').DocumentationAI;
      mockDocumentationAI.prototype.analyzeCodeChanges = jest.fn().mockRejectedValue(new Error('AI Error'));

      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

      const changes = [
        {
          type: 'modified' as const,
          file: 'src/api.ts',
          diff: 'diff content',
          timestamp: new Date()
        }
      ];

      await changeDetector.processChanges(changes);

      expect(consoleSpy).toHaveBeenCalledWith('Error processing changes:', expect.any(Error));
      consoleSpy.mockRestore();
    });
  });

  describe('performRollback', () => {
    it('should perform rollback successfully', async () => {
      const mockSimpleGit = require('simple-git');
      mockSimpleGit.mockReturnValue({
        revparse: jest.fn().mockResolvedValue('abc123'),
        reset: jest.fn().mockResolvedValue(undefined)
      });

      await changeDetector.performRollback('Test rollback');

      const rollbackHistory = changeDetector.getRollbackHistory();
      expect(rollbackHistory).toHaveLength(1);
      expect(rollbackHistory[0].reason).toBe('Test rollback');
    });

    it('should handle rollback errors', async () => {
      const mockSimpleGit = require('simple-git');
      mockSimpleGit.mockReturnValue({
        revparse: jest.fn().mockResolvedValue('abc123'),
        reset: jest.fn().mockRejectedValue(new Error('Git error'))
      });

      await expect(changeDetector.performRollback('Test rollback')).rejects.toThrow('Git error');
    });
  });

  describe('configuration management', () => {
    it('should get current configuration', () => {
      const config = changeDetector.getConfig();
      expect(config).toEqual(mockConfig);
    });

    it('should update configuration', () => {
      const newConfig = { autoSync: false };
      changeDetector.updateConfig(newConfig);

      const updatedConfig = changeDetector.getConfig();
      expect(updatedConfig.autoSync).toBe(false);
    });
  });

  describe('event handling', () => {
    it('should emit events during processing', async () => {
      const mockDocumentationAI = require('../documentation-ai.js').DocumentationAI;
      mockDocumentationAI.prototype.analyzeCodeChanges = jest.fn().mockResolvedValue([]);

      const eventSpy = jest.fn();
      changeDetector.on('processing-started', eventSpy);
      changeDetector.on('processing-completed', eventSpy);

      const changes = [
        {
          type: 'modified' as const,
          file: 'src/test.ts',
          diff: 'diff content',
          timestamp: new Date()
        }
      ];

      await changeDetector.processChanges(changes);

      expect(eventSpy).toHaveBeenCalledTimes(2);
    });
  });
});