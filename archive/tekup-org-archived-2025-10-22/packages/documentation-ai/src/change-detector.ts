import simpleGit, { SimpleGit, DiffResult } from 'simple-git';
import * as fs from 'fs/promises';
import * as path from 'path';
import { EventEmitter } from 'events';
import { DocumentationAI } from './documentation-ai.js';
import { CodeAnalyzer } from './code-analyzer.js';
import {
  DocumentationUpdate,
  AIConfig,
  CodeFile,
  ChangeDetectionConfig,
  ValidationResult,
  RollbackInfo
} from './types.js';

export interface ChangeDetectionConfig {
  watchPaths: string[];
  ignorePaths: string[];
  documentationPaths: string[];
  autoSync: boolean;
  validationEnabled: boolean;
  rollbackEnabled: boolean;
  webhookUrl?: string;
  notificationChannels: string[];
}

export interface GitChange {
  type: 'added' | 'modified' | 'deleted' | 'renamed';
  file: string;
  oldFile?: string;
  diff: string;
  timestamp: Date;
}

export interface ValidationResult {
  success: boolean;
  errors: string[];
  warnings: string[];
  affectedFiles: string[];
  rollbackRequired: boolean;
}

export interface RollbackInfo {
  id: string;
  timestamp: Date;
  changes: GitChange[];
  documentationUpdates: DocumentationUpdate[];
  reason: string;
}

export class ChangeDetector extends EventEmitter {
  private git: SimpleGit;
  private documentationAI: DocumentationAI;
  private codeAnalyzer: CodeAnalyzer;
  private config: ChangeDetectionConfig;
  private isWatching: boolean = false;
  private rollbackHistory: RollbackInfo[] = [];

  constructor(
    repositoryPath: string,
    aiConfig: AIConfig,
    config: ChangeDetectionConfig
  ) {
    super();
    this.git = simpleGit(repositoryPath);
    this.documentationAI = new DocumentationAI(aiConfig);
    this.codeAnalyzer = new CodeAnalyzer();
    this.config = config;
  }

  /**
   * Start monitoring codebase changes
   */
  async startWatching(): Promise<void> {
    if (this.isWatching) {
      console.warn('Change detector is already watching');
      return;
    }

    this.isWatching = true;
    console.log('Starting change detection...');

    // Set up Git hooks
    await this.setupGitHooks();

    // Start polling for changes (fallback)
    this.startPolling();

    this.emit('watching-started');
  }

  /**
   * Stop monitoring changes
   */
  async stopWatching(): Promise<void> {
    this.isWatching = false;
    console.log('Stopped change detection');
    this.emit('watching-stopped');
  }

  /**
   * Setup Git hooks for change detection
   */
  private async setupGitHooks(): Promise<void> {
    const hooksPath = path.join(await this.git.revparse(['--git-dir']), 'hooks');
    
    // Create post-commit hook
    const postCommitHook = `#!/bin/sh
# Auto-generated by TekUp Documentation AI
node -e "
const { ChangeDetector } = require('@tekup/documentation-ai');
const detector = new ChangeDetector('${process.cwd()}', {
  defaultProvider: 'openai',
  translationProvider: 'openai'
}, {
  watchPaths: ['apps/', 'packages/'],
  ignorePaths: ['node_modules/', 'dist/', '.git/'],
  documentationPaths: ['docs/', 'README.md'],
  autoSync: true,
  validationEnabled: true,
  rollbackEnabled: true,
  notificationChannels: []
});
detector.handleGitHook('post-commit');
"
`;

    const postCommitPath = path.join(hooksPath, 'post-commit');
    await fs.writeFile(postCommitPath, postCommitHook, { mode: 0o755 });

    // Create pre-push hook
    const prePushHook = `#!/bin/sh
# Auto-generated by TekUp Documentation AI
node -e "
const { ChangeDetector } = require('@tekup/documentation-ai');
const detector = new ChangeDetector('${process.cwd()}', {
  defaultProvider: 'openai',
  translationProvider: 'openai'
}, {
  watchPaths: ['apps/', 'packages/'],
  ignorePaths: ['node_modules/', 'dist/', '.git/'],
  documentationPaths: ['docs/', 'README.md'],
  autoSync: true,
  validationEnabled: true,
  rollbackEnabled: true,
  notificationChannels: []
});
detector.handleGitHook('pre-push');
"
`;

    const prePushPath = path.join(hooksPath, 'pre-push');
    await fs.writeFile(prePushPath, prePushHook, { mode: 0o755 });

    console.log('Git hooks installed successfully');
  }

  /**
   * Handle Git hook events
   */
  async handleGitHook(hookType: 'post-commit' | 'pre-push'): Promise<void> {
    try {
      console.log(`Handling ${hookType} hook`);

      if (hookType === 'post-commit') {
        await this.handlePostCommit();
      } else if (hookType === 'pre-push') {
        await this.handlePrePush();
      }
    } catch (error) {
      console.error(`Error handling ${hookType} hook:`, error);
      this.emit('hook-error', { hookType, error });
    }
  }

  /**
   * Handle post-commit hook
   */
  private async handlePostCommit(): Promise<void> {
    const changes = await this.getRecentChanges();
    
    if (changes.length === 0) {
      return;
    }

    console.log(`Detected ${changes.length} changes`);
    this.emit('changes-detected', changes);

    if (this.config.autoSync) {
      await this.processChanges(changes);
    }
  }

  /**
   * Handle pre-push hook
   */
  private async handlePrePush(): Promise<void> {
    if (this.config.validationEnabled) {
      const validation = await this.validateDocumentation();
      
      if (!validation.success) {
        console.error('Documentation validation failed:');
        validation.errors.forEach(error => console.error(`  - ${error}`));
        
        if (validation.rollbackRequired && this.config.rollbackEnabled) {
          await this.performRollback('Validation failed before push');
        }
        
        process.exit(1); // Prevent push
      }
    }
  }

  /**
   * Start polling for changes (fallback method)
   */
  private startPolling(): void {
    const pollInterval = 30000; // 30 seconds
    let lastCommit: string | null = null;

    const poll = async () => {
      if (!this.isWatching) return;

      try {
        const currentCommit = await this.git.revparse(['HEAD']);
        
        if (lastCommit && lastCommit !== currentCommit) {
          const changes = await this.getChangesBetweenCommits(lastCommit, currentCommit);
          
          if (changes.length > 0) {
            console.log(`Polling detected ${changes.length} changes`);
            this.emit('changes-detected', changes);
            
            if (this.config.autoSync) {
              await this.processChanges(changes);
            }
          }
        }
        
        lastCommit = currentCommit;
      } catch (error) {
        console.warn('Error during polling:', error);
      }

      setTimeout(poll, pollInterval);
    };

    poll();
  }

  /**
   * Get recent changes from Git
   */
  async getRecentChanges(commitCount: number = 1): Promise<GitChange[]> {
    try {
      const log = await this.git.log(['--oneline', `-${commitCount}`]);
      
      if (log.all.length === 0) {
        return [];
      }

      const latestCommit = log.latest;
      if (!latestCommit) {
        return [];
      }

      return this.getChangesForCommit(latestCommit.hash);
    } catch (error) {
      console.error('Error getting recent changes:', error);
      return [];
    }
  }

  /**
   * Get changes between two commits
   */
  async getChangesBetweenCommits(fromCommit: string, toCommit: string): Promise<GitChange[]> {
    try {
      const diff = await this.git.diff([`${fromCommit}..${toCommit}`, '--name-status']);
      const diffDetails = await this.git.diff([`${fromCommit}..${toCommit}`]);
      
      return this.parseDiffOutput(diff, diffDetails);
    } catch (error) {
      console.error('Error getting changes between commits:', error);
      return [];
    }
  }

  /**
   * Get changes for a specific commit
   */
  private async getChangesForCommit(commitHash: string): Promise<GitChange[]> {
    try {
      const diff = await this.git.diff([`${commitHash}^`, commitHash, '--name-status']);
      const diffDetails = await this.git.diff([`${commitHash}^`, commitHash]);
      
      return this.parseDiffOutput(diff, diffDetails);
    } catch (error) {
      console.error('Error getting changes for commit:', error);
      return [];
    }
  }

  /**
   * Parse Git diff output into structured changes
   */
  private parseDiffOutput(nameStatus: string, diffDetails: string): GitChange[] {
    const changes: GitChange[] = [];
    const lines = nameStatus.trim().split('\n');

    for (const line of lines) {
      if (!line.trim()) continue;

      const parts = line.split('\t');
      const status = parts[0];
      const file = parts[1];
      const oldFile = parts[2]; // For renames

      // Skip files that should be ignored
      if (this.shouldIgnoreFile(file)) {
        continue;
      }

      let type: GitChange['type'];
      switch (status[0]) {
        case 'A':
          type = 'added';
          break;
        case 'M':
          type = 'modified';
          break;
        case 'D':
          type = 'deleted';
          break;
        case 'R':
          type = 'renamed';
          break;
        default:
          type = 'modified';
      }

      // Extract diff for this file
      const fileDiff = this.extractFileDiff(diffDetails, file);

      changes.push({
        type,
        file,
        oldFile,
        diff: fileDiff,
        timestamp: new Date()
      });
    }

    return changes;
  }

  /**
   * Extract diff content for a specific file
   */
  private extractFileDiff(diffDetails: string, fileName: string): string {
    const lines = diffDetails.split('\n');
    const fileDiffLines: string[] = [];
    let inFileSection = false;

    for (const line of lines) {
      if (line.startsWith(`diff --git a/${fileName} b/${fileName}`)) {
        inFileSection = true;
        fileDiffLines.push(line);
      } else if (line.startsWith('diff --git') && inFileSection) {
        break; // Start of next file
      } else if (inFileSection) {
        fileDiffLines.push(line);
      }
    }

    return fileDiffLines.join('\n');
  }

  /**
   * Check if file should be ignored
   */
  private shouldIgnoreFile(filePath: string): boolean {
    // Check ignore patterns
    for (const ignorePattern of this.config.ignorePaths) {
      if (filePath.includes(ignorePattern)) {
        return true;
      }
    }

    // Check if file is in watch paths
    const isInWatchPath = this.config.watchPaths.some(watchPath => 
      filePath.startsWith(watchPath)
    );

    return !isInWatchPath;
  }

  /**
   * Process detected changes and update documentation
   */
  async processChanges(changes: GitChange[]): Promise<void> {
    console.log(`Processing ${changes.length} changes...`);
    this.emit('processing-started', changes);

    try {
      // Analyze changes for documentation updates
      const allDiff = changes.map(change => change.diff).join('\n\n');
      const documentationUpdates = await this.documentationAI.analyzeCodeChanges(allDiff);

      if (documentationUpdates.length === 0) {
        console.log('No documentation updates needed');
        this.emit('processing-completed', { changes, updates: [] });
        return;
      }

      console.log(`Generated ${documentationUpdates.length} documentation updates`);
      this.emit('updates-generated', documentationUpdates);

      // Apply documentation updates
      const appliedUpdates = await this.applyDocumentationUpdates(documentationUpdates);

      // Validate updates if enabled
      if (this.config.validationEnabled) {
        const validation = await this.validateDocumentation();
        
        if (!validation.success) {
          console.error('Documentation validation failed after updates');
          
          if (this.config.rollbackEnabled) {
            await this.performRollback('Validation failed after documentation updates');
            return;
          }
        }
      }

      // Commit documentation changes
      if (appliedUpdates.length > 0) {
        await this.commitDocumentationChanges(appliedUpdates);
      }

      this.emit('processing-completed', { changes, updates: appliedUpdates });
    } catch (error) {
      console.error('Error processing changes:', error);
      this.emit('processing-error', { changes, error });

      if (this.config.rollbackEnabled) {
        await this.performRollback(`Processing error: ${error}`);
      }
    }
  }

  /**
   * Apply documentation updates to files
   */
  private async applyDocumentationUpdates(updates: DocumentationUpdate[]): Promise<DocumentationUpdate[]> {
    const appliedUpdates: DocumentationUpdate[] = [];

    for (const update of updates) {
      try {
        console.log(`Applying update: ${update.type} (${update.priority})`);
        
        // Apply changes to each file
        for (const filePath of update.files) {
          await this.updateDocumentationFile(filePath, update);
        }

        appliedUpdates.push(update);
        this.emit('update-applied', update);
      } catch (error) {
        console.error(`Error applying update for ${update.files.join(', ')}:`, error);
        this.emit('update-error', { update, error });
      }
    }

    return appliedUpdates;
  }

  /**
   * Update a specific documentation file
   */
  private async updateDocumentationFile(filePath: string, update: DocumentationUpdate): Promise<void> {
    try {
      // Check if file exists
      let content = '';
      try {
        content = await fs.readFile(filePath, 'utf-8');
      } catch {
        // File doesn't exist, create it
        console.log(`Creating new documentation file: ${filePath}`);
      }

      // Apply suggested changes
      let updatedContent = content;
      for (const change of update.suggestedChanges) {
        // This is a simplified implementation
        // In practice, this would be more sophisticated
        updatedContent += `\n\n${change}`;
      }

      // Write updated content
      await fs.writeFile(filePath, updatedContent, 'utf-8');
      console.log(`Updated documentation file: ${filePath}`);
    } catch (error) {
      console.error(`Error updating file ${filePath}:`, error);
      throw error;
    }
  }

  /**
   * Validate documentation accuracy and completeness
   */
  async validateDocumentation(): Promise<ValidationResult> {
    const errors: string[] = [];
    const warnings: string[] = [];
    const affectedFiles: string[] = [];

    try {
      // Check documentation files exist
      for (const docPath of this.config.documentationPaths) {
        try {
          await fs.access(docPath);
        } catch {
          errors.push(`Documentation file not found: ${docPath}`);
          affectedFiles.push(docPath);
        }
      }

      // Validate markdown syntax
      for (const docPath of this.config.documentationPaths) {
        if (docPath.endsWith('.md')) {
          try {
            const content = await fs.readFile(docPath, 'utf-8');
            const markdownErrors = this.validateMarkdown(content);
            errors.push(...markdownErrors.map(err => `${docPath}: ${err}`));
            
            if (markdownErrors.length > 0) {
              affectedFiles.push(docPath);
            }
          } catch (error) {
            warnings.push(`Could not validate ${docPath}: ${error}`);
          }
        }
      }

      // Check for broken links (simplified)
      // In practice, this would be more comprehensive
      
      return {
        success: errors.length === 0,
        errors,
        warnings,
        affectedFiles,
        rollbackRequired: errors.length > 0
      };
    } catch (error) {
      return {
        success: false,
        errors: [`Validation error: ${error}`],
        warnings,
        affectedFiles,
        rollbackRequired: true
      };
    }
  }

  /**
   * Validate markdown syntax
   */
  private validateMarkdown(content: string): string[] {
    const errors: string[] = [];

    // Check for unmatched brackets
    const openBrackets = (content.match(/\[/g) || []).length;
    const closeBrackets = (content.match(/\]/g) || []).length;
    if (openBrackets !== closeBrackets) {
      errors.push('Unmatched square brackets in markdown');
    }

    // Check for unmatched parentheses in links
    const openParens = (content.match(/\(/g) || []).length;
    const closeParens = (content.match(/\)/g) || []).length;
    if (openParens !== closeParens) {
      errors.push('Unmatched parentheses in markdown');
    }

    // Check for empty links
    if (content.includes(']()')){
      errors.push('Empty links found in markdown');
    }

    return errors;
  }

  /**
   * Perform rollback of documentation changes
   */
  async performRollback(reason: string): Promise<void> {
    console.log(`Performing rollback: ${reason}`);
    
    try {
      // Get current state before rollback
      const currentCommit = await this.git.revparse(['HEAD']);
      
      // Reset to previous commit (simplified)
      await this.git.reset(['--hard', 'HEAD~1']);
      
      // Record rollback
      const rollbackInfo: RollbackInfo = {
        id: `rollback-${Date.now()}`,
        timestamp: new Date(),
        changes: [], // Would include the changes that were rolled back
        documentationUpdates: [], // Would include the updates that were rolled back
        reason
      };
      
      this.rollbackHistory.push(rollbackInfo);
      
      console.log(`Rollback completed: ${rollbackInfo.id}`);
      this.emit('rollback-completed', rollbackInfo);
    } catch (error) {
      console.error('Error performing rollback:', error);
      this.emit('rollback-error', { reason, error });
      throw error;
    }
  }

  /**
   * Commit documentation changes
   */
  private async commitDocumentationChanges(updates: DocumentationUpdate[]): Promise<void> {
    try {
      // Stage documentation files
      for (const docPath of this.config.documentationPaths) {
        try {
          await this.git.add(docPath);
        } catch {
          // File might not exist or be modified
        }
      }

      // Create commit message
      const updateTypes = [...new Set(updates.map(u => u.type))];
      const commitMessage = `docs: auto-update documentation (${updateTypes.join(', ')})

${updates.map(u => `- ${u.type}: ${u.suggestedChanges[0] || 'Updated documentation'}`).join('\n')}

Generated by TekUp Documentation AI`;

      // Commit changes
      await this.git.commit(commitMessage);
      console.log('Documentation changes committed');
      this.emit('documentation-committed', { updates, commitMessage });
    } catch (error) {
      console.error('Error committing documentation changes:', error);
      this.emit('commit-error', { updates, error });
    }
  }

  /**
   * Get rollback history
   */
  getRollbackHistory(): RollbackInfo[] {
    return [...this.rollbackHistory];
  }

  /**
   * Get current configuration
   */
  getConfig(): ChangeDetectionConfig {
    return { ...this.config };
  }

  /**
   * Update configuration
   */
  updateConfig(newConfig: Partial<ChangeDetectionConfig>): void {
    this.config = { ...this.config, ...newConfig };
    this.emit('config-updated', this.config);
  }
}